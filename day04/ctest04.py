# -*- coding: utf-8 -*-
"""CTEST04.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qH5VSCbsWGXiuDKszXaeOExzBJhJmhkU

# DFS/BFS
* 그래프를 탐색하기 위한 대표적인 두가지 알고리즘
## 자료구조 기초
* 탐색 : 데이터 중에서 원하는 데이터를 찾는 과정
  * 탐색(검색)알고리즘 2톱
    * DFS, BFS
* 자료구조 : 데이터를 표현하고 관리하고 처리하기 위한 구조
  * 삽입(PUSH) : 데이터를 삽입한다
  * 삭제(POP) : 데이터를 삭제한다
* 오버플로 : 특정한 자료구조가 수용할 수 있는 데이터 크기를 이미 가득찬 상태에 삽인연산을 수행할 시 나옴
* 언더플로 : 데이터가 전혀 들어가있지 않을때 삭제연산을 수행할 시 나옴
* 자료구조 기초 : 스택, 큐
* 재귀함수

## 스택 
* 차례로 쌓고, 차례로 뺀다
* 선입후출 구조, 후입선출구조
"""

stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.pop()

print(stack)
print(stack[::-1]) # 최상단 부터 출력

"""## 큐
* 당구공
* 선입선출, 후입후출

### 파이썬에서는 collections 에 deque(덱) 라이브러리 를 사용할 수 있다.(양방향 큐)
"""

from collections import deque

# 큐(Queue) 구현을 위해 deque 라이브러리 사용
queue = deque()

queue.append(5)
queue.append(3)
queue.append(2)
queue.popleft()
queue.append(8)
queue.append(9)

print(queue)
queue.reverse() # 역순
print(queue)

"""## 재귀 함수
* 자신을 다시 호출하는 함수
* DFS, BFS 구현시 필수적인 함수
* 종료조건을 명시해줘야 된다.

* 재귀함수는 수학에서 점화식을 그대로 옮겨놓은 형태로 짤수 있기때문에 **간결한** 코드를 짤 수 있다.
"""

# math를 사용하지 않고 팩토리얼 구현

# 반복적으로 구현한 n!
def factorial_iteragive(n):
  result = 1
  # 1 부터  n 까지의 수를 차례대로 곱하기
  for i in range(1, n+1):
    result *= i
  
  return result

# 재귀적으로 구현한 n!
def factorial_recursive(n):
  if n <= 1 :
    return 1
  
  return n* factorial_recursive(n-1)

print('반복적 구현 : ',factorial_iteragive(5))
print('재귀적 구현 : ',factorial_recursive(5))

"""# 탐색알고리즘 DFS/BFS
* DFS : Depth-First-Search 깊이 우선 탐색
* BFS : Breadth First Search 너비 우선 탐색

## DFS
* 깊이우선 탐색
* 인접행렬 : 2차원 배열로 그래프의 연결관계를 표현하는 방식
  * 넣을수 없는 값은 9999999.. 와같은 무한대수로 초기화하는 경우가 많다
  * INF로 표현
* 인접리스트 : 리스트로 그래프 연결관계를 표현하는 방식
"""

# 인접행렬
INF = 9999999999 # 무한의 비용 선언

# 2차원 리스트를 이용해 인접 행렬 표현
graph =[
        [0,7,5],
        [7,0,INF],
        [5,INF,0]
]

print(graph)

"""* 인접 리스트 방식에서는 모든노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
* 연결리스트(링크드리스트) 는 C++, Java 와 같은 프로그래밍언어에서 별도로 제공
  * 파이썬에서는 append()메소드 제공을 하여 정통적인 프로그래밍언어의 연결리스트 기능 모두 제공한다.
  * 파이썬에선 인접리스트를 표현할 때 2차원 리스트를 이용하면 된다.
"""

# 행(Row)이 3개인 2차원 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1,7))
graph[0].append((2,5))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0,7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0,5))

print(graph)

"""* 메모리 속도측면에서 인접행렬 보다 인접리스트가 더많은 데이터를 관리하기에 좋다.
  * 연결된 정보만 저장하는 인접리스트
  * 특정한 두노드가 연결되어 있는지 얻는 속도는 느리다.(하나씩 다 확인해봐야해서)
* 특정한 노드와 연결된 모든 인접노드를 순회 : 인접리스트 방식

# DFS 구현
"""