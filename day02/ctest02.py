# -*- coding: utf-8 -*-
"""CTEST02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B_EDbr7QoVqRmmuWn5PUqyvHekJdqgbq

---
# 그리디
* 당장 좋은 것만 선택하는 그리디
"""



"""## 큰수의 법칙
* 주어진 숫자들을 M번 더하여 가장큰 수를 만드는 법칙
* K번 연속으로 더해질 수 없음.
* 예) 1,2,3,4,5 -> m = 7, k = 3 -> 5+5+5+4+5+5+5
"""

""" 
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때
동빈이의 큰수의 법칙 결과를 출력하시오
"""
# N,M,K 공백으로 구분하여 받기
n, m, k = map(int,input().split())

# N개의 수 공백 구분하여 받기
data = list(map(int,input().split()))

# 입력 값 정렬
data.sort()

# 가장 큰수
first = data[n-1]
# 두번째 큰수
second = data[n-2]

# M번 동안 연속K번 더하여 가장 큰 수 받기
result = 0
while True:
    for i in range(k):
        if (m==0):
            break
        result += first
        m-=1
    if (m==0):
        break
    result += second
    m-=1

print(result) # 최종 답안 출력

# M이 무수히 많아지면 무겁고 느려진다.
# 수학을 통해 해결해보자.
# ( 가장 큰수 * k ) * 가장 큰수 반복횟수
# 두번째 큰수 * 두번째반복횟수
# 가장큰수 반복횟수 = (( M // (K+1) ) * K )+ (M % (K+1))
# 두번째큰수 반복횟수 = ( M // (K+1))

# n개, m번, k까지
n, m, k = map(int,input().split())

# 받을 숫자 리스트
data = list(map(int,input().split()))

# 반복횟수
second_count = (m // (k+1))
first_count = (second_count * k) + (m%(k+1))

data.sort() # 리스트 정렬

# 가장 큰 값, 두번째 큰 값
first_data = data[n-1]
second_data = data[n-2]

# 결과 도출
result = first_data * first_count
result += second_data * second_count

print(result)

"""## 숫자 카드 게임
* 여러 숫자중 가장 높은 숫자를 뽑아야하는 게임
* N * M 형태로 나열되어있음
* 행 중에서 가장낮은 숫자 중에서 가장 높은숫자를 고르는 것



"""

# N, M 입력
n, m = map(int, input().split())

result = 0
# 리스트 입력으로 값 넣기
for i in range(m):
  data = list(map(int,input().split()))
  # 한 줄마다 최소값 구하기 
  min_value = min(data)
  # 그 중에서 가장 큰 결과값 확인
  result = max(result, min_value)

# 결과값 출력
print(result)

"""## 1이 될때 까지
* 어떠한 수 n이 1이 될때까지 다음 두 과정 중 하나를 반복적으로 선택하려한다.
  * 1. N에서 1을 뺀다
  * 2. N에서 k를 나눈다.
* 1,2번 과정 수행횟수 중에서 최소 횟수를 구하는 프로그램 만들기
"""

# N, K 받기
n, k = map(int, input().split())

# 2번과정 먼저하고, 나머지를 1번과정으로 하기
result = 0

while n != 0:
  if n % k == 0:
    n = int(n / k)
  else:
    n -=1
  result += 1
  # print(n)

result -=1 # 마지막 계산은 횟수에서 제외
print(result)

"""# 구현
* 피지컬로 승부하기
* 알고리즘은 설게했는데, 구현이 먼저 풀수 있는 문제가 없을때 푸는게 좋다.
  * 쉬운 문제이지만 노가다 구현인건 먼저 풀지 말라 이소리인듯.
* 완전탐색 : 모든 경우의 수를 주저없이 다 계산하는 해결방법
* 시뮬레이션 : 한단계씩 차례대로 직접 수행해야하는 문제 유형

## 메모리 제약사항 확인

### 숫자
* 보통 정수형은 int형(4바이트),  더큰수는 long long(8바이트)
* 더큰수는 Bitinteger(클래스) : 보통 안쓴다.

### 파이썬 리스트 메모리 용량
* 1,000 개 : 4kb
* 1,000,000개 : 4mb
* 1,000,000,000개 : 40mb

* 파이썬은 동작이 매우 느리다.

### 구현문제에 접근하는 방법
* 문제길이가 길 뿐이지, 비교적 쉬운문제들이다.
* 파이썬이 구현문제에서는 강한 편이다.
* Pypy3 : python3 문법 그대로 쓰이는 프로그래밍 언어. 비교적 빠른 프로그램 실행시간을 가짐
  * Pypy3를 지원한다고 하면 시험을 Pypy3로 치자.

## 상하좌우
* 여행가 문제 : L R U D 를 통해 최종적으로 도착할 좌표 출력하기
  * 첫번째 줄 입력란은 공간의 크기 N
  * 둘째 줄 입력란엔 A가 이동할 계획서 내용이 주어진다.
  * 출력 조건 : A가 이동할 최종 목표지전 X,Y를 공백으로 구분하여 출력한다.
"""

